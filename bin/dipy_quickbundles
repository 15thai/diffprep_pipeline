#! /usr/bin/env python
import argparse as arg
import os

import numpy as np
import scipy.io as sio

from nibabel import trackvis
import dipy.segment.quickbundles as qb

parser = arg.ArgumentParser(description='Segment a mrDiffusion FiberGroup object into clusters using QuickBundles (Garyfallidise et al. 2012)')

parser.add_argument('in_file', action='store', metavar='File', 
                    help='FG file (.mat)')

parser.add_argument('--dist_thr', action='store', metavar='Float',
                    help='Distance threshold (default: 30.)', default=30.)

parser.add_argument('--pts',  action='store', metavar='Int',
                    help='Points (default: 12)', default=12)

params = parser.parse_args()

if __name__ == "__main__":
    def gimme_clusters(streamlines, th, pts):
        bundles = qb.QuickBundles(streamlines,
                                  dist_thr=th,
                                  pts=pts)
    
        return bundles.clusters()
    fname_orig = params.in_file

    if params.in_file.endswith('.trk'):
        tracks = trackvis.read(params.in_file)
        streamlines = [fibers[0] for fibers in tracks[0]]
        clusters = gimme_clusters(streamlines, params.dist_thr, params.pts)
        for c in clusters:
            new_streamlines = new_streamlines = [(s, None, None) for s in
                                np.array(streamlines)[clusters[c]['indices']]]
            split = os.path.splitext(fname_orig)
            trackvis.write(split[0] + '_%s'%(c + 1) + split[1],
                           new_streamlines)

    if params.in_file.endswith('.mat'):
        # Once read this as a mat-object
        fg_mat = sio.loadmat(params.in_file, struct_as_record=False,
                             squeeze_me=True)
        # So that you can painlessly get the fiber-group:
        fg = fg_mat['fg']
        # And once as a non-struct, so that you can use this later to pass back
        # to savemat:
        fg_mat = sio.loadmat(params.in_file, squeeze_me=True)
        name_orig = fg.name
        fibers = fg.fibers
        streamlines = np.array([np.array(ff).T for ff in fibers])
        clusters = gimme_clusters(streamlines, params.dist_thr, params.pts)

        dt = [('name', 'O'),
              ('colorRgb', 'O'),
              ('thickness', 'O'),
              ('visible', 'O'),
              ('seeds', 'O'),
              ('seedRadius', 'O'),
              ('seedVoxelOffsets', 'O'),
              ('params', 'O'),
              ('fibers', 'O'),
              ('query_id', 'O')]

        cluster_arr = np.empty(len(clusters), dtype=dt)
        for c in clusters:
            ff = streamlines[clusters[c]['indices']]
            new_fibers = np.empty(len(ff), dtype=object)
            for f in range(new_fibers.shape[0]):
                new_fibers[f] = ff[f].T

            cluster_arr[c]['fibers'] = new_fibers
            cluster_arr[c]['colorRgb']=\
                np.array(fg.colorRgb).astype(np.float).reshape(1,3)
            cluster_arr[c]['name'] = str(name_orig) + '_%s'%(c + 1)

            for d in dt:
                if cluster_arr[c][d[0]] is None:
                    try:
                        cluster_arr[c][d[0]] = fg_mat['fg'][d[0]]
                    except TypeError:
                        print fg_mat['fg']
                        foo
        split = os.path.splitext(fname_orig)
        fg_mat['fg'] = cluster_arr
        sio.savemat(split[0] + '_cluster.mat',
                    fg_mat)
