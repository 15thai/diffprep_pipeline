#! /usr/bin/env python
import argparse as arg
import os
import warnings 
import dipy.io.pickles as pkl

import numpy as np
import scipy.io as sio
import matplotlib.cm as cm

from nibabel import trackvis
import dipy.segment.quickbundles as qb

parser = arg.ArgumentParser(description='Segment a fiber-group into clusters using the QuickBundles algorithm (Garyfallidis et al. 2012)')

parser.add_argument('in_file', action='store', metavar='File', 
                    help='Vistasoft fiber-group file (.mat) or Trackvis fiber file (.trk)')

parser.add_argument('--dist_thr', action='store', metavar='Float',
                    help='Distance threshold (default: 30.)', default=30.)

parser.add_argument('--pts',  action='store', metavar='Int',
                    help='Points (default: 12)', default=12)
                    
parser.add_argument('--pkl_file', action='store', metavar='File',
		    help='Whether to save a QB object in pickle format. Provide full path to the file name (default: none)')

parser.add_argument('--out_file', action='store', metavar='File', 
                    help='Full path to the output file name (defaults to the same location as the original input file')


params = parser.parse_args()

if __name__ == "__main__":
    def gimme_clusters(streamlines, th, pts):
        bundles = qb.QuickBundles(streamlines,
                                  dist_thr=th,
                                  pts=pts)
        return bundles, bundles.clusters()
    
    fname_orig = params.in_file
    split = os.path.splitext(fname_orig)

    if params.in_file.endswith('.trk'):
        tracks, hdr = trackvis.read(params.in_file)
        streamlines = [fibers[0] for fibers in tracks]
        bundles, clusters = gimme_clusters(streamlines,
                                           np.float(params.dist_thr),
                                           np.int(params.pts))
        for c in clusters:
            new_streamlines = new_streamlines = [(s, None, None) for s in
                                np.array(streamlines)[clusters[c]['indices']]]

            if params.out_file:
                this_split = params.out_file.split('.')
                out_fname = this_split[0] + '_%s'%(c + 1) + '.trk'
            else:
                out_fname = split[0] + '_%s'%(c + 1) + split[1]
                
            trackvis.write(out_fname, new_streamlines, hdr)

    elif params.in_file.endswith('.mat'):
        # Once read this as a mat-object
        fg_mat = sio.loadmat(params.in_file, struct_as_record=False,
                             squeeze_me=True)
        # So that you can painlessly get the fiber-group:
        fg = fg_mat['fg']
        # And once as a non-struct, so that you can use this later to pass back
        # to savemat:
        fg_mat = sio.loadmat(params.in_file, squeeze_me=True)
        name_orig = fg.name
        fibers = fg.fibers
        streamlines = np.array([np.array(ff).T for ff in fibers])
        bundles, clusters = gimme_clusters(streamlines,
                                           np.float(params.dist_thr),
                                           np.int(params.pts))
        # We will give each cluster a different color:
        cmap = cm.get_cmap('jet', len(clusters)) 
        cmap_arr = cmap(np.arange(len(clusters)))[:, :3]  # We don't need alpha

        # We prepare a struct array to assign into with the original dtype:
        dt = [('name', 'O'),
              ('colorRgb', 'O'),
              ('thickness', 'O'),
              ('visible', 'O'),
              ('seeds', 'O'),
              ('seedRadius', 'O'),
              ('seedVoxelOffsets', 'O'),
              ('params', 'O'),
              ('fibers', 'O'),
              ('query_id', 'O')]
        cluster_arr = np.empty(len(clusters), dtype=dt)

        for c in clusters:
            ff = streamlines[clusters[c]['indices']]
            new_fibers = np.empty(len(ff), dtype=object)
            for f in range(new_fibers.shape[0]):
                new_fibers[f] = ff[f].T

            cluster_arr[c]['fibers'] = new_fibers
            cluster_arr[c]['colorRgb']=\
                np.array(cmap_arr[c]).astype(np.float).reshape(1,3)
            cluster_arr[c]['name'] = str(name_orig) + '_%s'%(c + 1)

            for d in dt:
                if cluster_arr[c][d[0]] is None:
                    try:
                        cluster_arr[c][d[0]] = fg_mat['fg'][d[0]]
                    except TypeError:
                        print fg_mat['fg']
                        foo
        fg_mat['fg'] = cluster_arr
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            if params.out_file:
                out_fname = params.out_file
            else:
                out_fname = split[0] + '_cluster.mat'

            sio.savemat(out_fname,fg_mat)
    else:
        raise ValueError('Unrecognized file-format')

    if params.pkl_file:
        pkl.save_pickle(params.pkl_file, bundles)
